# PCD Module 5.2

**Ingegneria dei sistemi distribuiti: architetture orientate ai servizi**

## Servizi

### Un mondo di servizi

I servizi sono al giorno d'oggi l'approccio principale per progettare e costruire sistemi distribuiti basati su Internet. Un servizio è un componente software fornito tramite un endpoint accessibile tramite la rete.

Due principali visioni in competizione e convergenza:

- **SOA basato su "grandi" web services**, concepiti per applicazioni a livello aziendale
- **Webservice REStful**: risorse esposte come webservice, adottato sempre di più a livello aziendale e per SOA
- **Microservizi**: trend più recente

## SOA basato su web services

### Architetture orientate ai servizi (SOA)

- La logica richiesta per risolvere grandi problemi può essere gestita meglio se decomposta in piccoli pezzi. Ciò che distingue l'approccio SOA è il modo in cui viene effettuata la separazione.
- Autogoverno e autonomia dei servizi individuali: indipendenza tra servizi e possibile eterogeneità delle tecnologie e linguaggi di implementazione.
- Interoperabilità: stabdard condivisi, ruolo chiave delle interfacce, contratti che regolano i servizi di produttori e consumatori.

### Descrizioni dei servizi, messaggi

Un servizio è fornito da un qualche provider di servizi e consumato da consumatori o richiedenti. Un servizio ha una descrizione, funzionante come contratto e serve per essere ritrovato. 

I servizi si relazionano tramite l'uso dei messaggi: in tal senso serve un framewok per la messaggistica. Il messaggio è l'unità indipendente di comunicazione.

### Principi SOA

I servizi:

-  **sono riusabili**
-  **condividono un contratto formale** per interagire e scambiare informazioni
-  **sono poco accoppiati**: devono interagire senza bisogno di dipendenze forti e intra-servizi
-  **astraggono la logica sottostante**: l'unica parte di un servizio visibile dall'esterno è il contratto. Tutto ciò che sta sotto è irrilevante a chi richiede il servizio.
-  **sono componibili**: servizi possono comporre altri servizi.
-  **sono autonomi**: la logica che governa un servizio ha certi confini. Il servizio ha controllo all'interno di tali confini.
-  **sono senza stato**: non devono gestire informazioni sullo stato e devono essere progettati per la massima statelessinesità.
-  **sono ritrovabili**: le loro descrizioni devono essere ritrovabili da umani e altri servizi.

### SOA con webservice

Un webservice è l'esempio di un SOA con un set ben definito di tecnologie: **XML**, **SOAP** e **WSDL**, più lo stack standard dei ws (sicurezza, affidabilità, trust, ecc...)

Obiettivo primario: fornire **interoperabilità** tra stack di middleware eterogenei e affidare l'accoppiamento debole di consumatore e fornitore.

Modello di servizio: 

- consumatore e fornitore usano **messaggi** per scambiare richieste e risposte nel formato di documenti auto-contenuti che fanno poche assunzioni sulle capacità tecnologiche del ricevitore (es. rendere disponibile un PDF e non sapere se il consumatore abbia Adobe Reader installato)
- non c'è nozione di riferimento ad oggetti remoti che possa richiedere ad un broker di oggetti di gestire uno spazio di memoria distribuito
- fornisce interoperabilità tra RPC e stili di integrazione dei messaggi

### SOAP

- **SOAP**: linguaggio XML che definisce un'architettura per i messaggi e il loro formato, fornendo anche un protocollo di processazione rudimentale.
- Il documento SOAP definisce un elemento top-leveel XML chiamato **envelope**, che contiene un header e un body.
	- **Header**: un container estendibile per informazioni a livello di messaggi che può essere usato per pianificare scopi (es. indirizzamento) e configurazioni QoS (transazioni, sicurezza, affidabilità...). 
	- **Body**: contiene il payload
- Lo schema XML è usato per descrivere la struttura di un messaggio SOAP, cosicchè i motori SOAP ai due estremi possono marscellare e demarscellare il contenuto del messaggio e indirizzarlo all'implementazione appropriata.

**Esempio**

```
<?xml version="1.0"?><soap:Envelopexmlns:soap="http://www.w3.org/2001/12/soap-envelope"soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"><soap:Body>  <m:GetPrice xmlns:m="http://www.w3schools.com/prices">    <m:Item>Apples</m:Item>  </m:GetPrice></soap:Body></soap:Envelope>
``` 

### WSDL

- Linguaggio XML per definire le interfacce
- **port type**: specifica operazioni di astrazione multiple, associate con diversi messaggi in arrivo e in uscita.
- **binding**: collega l'insieme di operazioni astratte con protocolli di trasporto concreti e formati di serializzazione (es. HTTP)
- Gli endpoint sono indirizzati sul livello di trasporto con URI per endpoint SOAP/HTTP, o a livello di messaggio tramite indirizzamento WS.

**Esempio**
```
<message name="getTermRequest">  <part name="term" type="xs:string"/></message><message name="getTermResponse">  <part name="value" type="xs:string"/></message><portType name="glossaryTerms">  <operation name="getTerm">    <input message="getTermRequest"/>    <output message="getTermResponse"/>  </operation></portType><binding type="glossaryTerms" name="b1">   <soap:binding style="document"   transport="http://schemas.xmlsoap.org/soap/http" />   <operation>     <soap:operation soapAction="http://example.com/getTerm"/>     <input><soap:body use="literal"/></input>     <output><soap:body use="literal"/></output>  </operation></binding>
```

### Lo stack WS completo

Lo stack di tecnologie WS copre diverse funzionalità di QoS richieste per assicurare l'interoperabilità di sistemi middleware avanzati. Data la modularità e la componibilità dell'approccio, ha portato ad un grande set di specifiche WS.

Schema su slide

### Implementazioni

.NET WCF, JAX-WS, Apache Axis2, Eclipse Web Tools

## SOA basato su REST

### L'alba di un'era basata su REST

**REST**: REpresentational State Transfer, stile architetturale per costruire sistemi ipermediali distribuiti su larga scala. Principi usati per spiegare la scalabilità di HTTP 1.0 e hanno vincolato la progettazione di HTTP 1.1.

#### REST come architettura software

REST può essere descritta come un'architettura indipendente da tecnologia e piattaforma dove componenti poco accoppiati comunicano tramite interfacce su protocolli web standard. 

REST si differenzia dalle architetture degli altri software perchè sposa il concetto di architettura software comune sulla rete. LA combunazione rende REST ideale per software distribuiti dove la **scalabilità** è fondamentale

#### Webservice RESTful

Webservice basati sui principi REST per implementare chiamate a procedure remote sul web. Interesse in aumento non solo per l'uso nelle API ma anche perchè pubblicare e consumare WS REST è facile e semplice. Standard de facto.

### Principi REST

- **Identificazione delle risorse tramite URI**: un WS REST espone un insieme di risorse che identificano l'obiettivo di interazione col client. Le risorse sono identificate tramite URI, che fornisce uno spazio di indirizzazione globale per risorse e servizi.
- **Interfaccia uniforme**: le risorse sono manipolate tramite un set fisso di operazioni `PUT` `GET` `POST` `DELETE`
- **Messaggi auto-descrittivi**: le risorse sono disaccoppiate dalla rappresentazione, cosicchè il loro contenuto può essere acceduto in diversi formati (HTML, XML, JSON, TXT...). Sono disponibili metadati per le risorse.
- **Interazione senza stato tramite iperlink**: ogni interazione con una risorsa è senza stato e sono basate sul concetto di **trasferimento esplicito dello stato**, tramite diverse tecniche (riscrittura URI, cookies, ecc.). Lo stato può essere incluso nei messaggi di risposta.

#### Rappresentazione delle risorse

- JSON, XML
- Link ad altre risorse tramite URI (es. www.service.com/user/1234)

#### Formato richieste HTTP (esempi)

```
GET http://www.w3.org/Protocols/rfc2616/rfc2616.html HTTP/1.1Host: www.w3.orgAccept: text/html,application/xhtml+xml,application/xml; ...User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 ...Accept-Encoding: gzip,deflate,sdchAccept-Language: en-US,en;q=0.8,hi;q=0.6

POST http://MyService/Person/Host: MyServiceContent-Type: text/xml; charset=utf-8Content-Length: 123<?xml version="1.0" encoding="utf-8"?><Person>  <ID>1</ID>  <Name>Alda Merini</Name>  <Email>alda.merini@gmail.com</Email>  <Country>Italy</Country></Person>
```

#### Formato risposte HTTP (esempi)

```
GET
HTTP/1.1 200 OKDate: Sat, 23 Aug 2014 18:31:04 GMTServer: Apache/2Last-Modified: Wed, 01 Sep 2004 13:24:52 GMTAccept-Ranges: bytesContent-Length: 32859Cache-Control: max-age=21600, must-revalidateExpires: Sun, 24 Aug 2014 00:31:04 GMTContent-Type: text/html; charset=iso-8859-1<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns='http://www.w3.org/1999/xhtml'><head><title>Hypertext Transfer Protocol -- HTTP/1.1</title></head><body>...
```

### Sistemi RESTful

#### Interazione client-server

L'interazione client-server è la fondamenta di sistemi su scala di Internet, evoluzione di componenti indipendenti, raggiungimento pervasivo. Le interazioni CS disaccoppiano i client dai server REST e rinforzano la separation of concerns. Ristringendo le interazioni ai protocolli internet, formato dei messaggi e linguaggi di script, diversi client di piattaforme possono connettersi a risorse lato server.

#### Comunicazione senza stato

Quando una comunicazione è senza stato, ogni richiesta accade in isolazione e i lclient è responsabile di mantenere lo stato. La richiesta del client contiene tutte le info richieste per processare la richiesta, e un server RESTful non usa informazioni sullo stato locale da una richiesta precedente. 

#### Dati cacheabili

I sistemi RESTful contrassegnano i dati come cacheabili e li rispettano. I dati in cache riducono il traffico di rete e riducono il carico lato backend. Nodi intermediari possono avere cache. In un sistema REST, gli intermediari riconoscono la freschezza delle informazioni. 

#### Interfacce uniformi

- Identificazione risorse
- Manipolazione risorse tramite rappresentazione
- Presentazione di messaggi autodesctrittivi
- Si appoggia a HATEOAS (ipermedia come motore dello stato dell'applicazione)

Le interfacce uniforme dovrebbero identificare il comportamento dei messaggi e la semantica senza guardare al body. Le interfacce uniformi non dipendono dagli stati in cui i messaggi sono salvati. 

#### Sistemi stratificati

Creando un sistema stratificato, i team possono evolvere i componenti server e client indipendentemente. Le API di facciata nascondono le implementazioni interne.

#### Codice su richiesta (C-o-D)

Permette ai client di estendere funzionalità scaricando ed eseguendo codice localmente. Il sistema riduce il numero di feature pre-richieste e migliora l'estendibilità del sistema.

### Servizi RESTful vs Non-RESTful

```
– NOTRESTful             GET /updateuser?name=Robert&newname=Bob HTTP/1.1– RESTful              PUT /users/Robert HTTP/1.1Host: myserverContent-Type: application/xml<?xml version="1.0"?><user>  <name>Bob</name></user>
```

### SOA con REST

- **Servizio**: programma software che rende disponibili le proprie funzionalità tramite un'interfaccia tecnica (contratto).
- **Contratto e capacità**: contratto spacchettato in termini di capacità del servizio (funzioni offerte)
- **Consumatore**: ruolo assunto dal programma software che accede al servizio. Una volta ricevuta la richiesta, il servizio inizia la computazione. Può o può non tornare un messaggio di risposta.

#### Elementi uniformi del contratto

- **Sintassi del resource identifier**: come esprimere i dati trasferiti - URI HTTP
- **Metodi**: quali sono i meccanismi usati per trasferire i dati - metodi HTTP Get, Post, Put, Delete
- **Tipo di media**: quali tipi di dati sono trasferiti - JSON, XML...

#### Sintassi

`{scheme}://{authority}{path}?{query}#{fragment}`

Esempi: ` http://customer.example.com/customer/C081` `http://customer.example.com/invoice?total-less- than=100USD#page2`

#### Modelli di servizio

- **Entity**: servizi relativi alle entità, es. `GET /invoice/{invoice-id}`
- **Task**: servizi relativi a compiti da eseguire, es. `POST /start/{taskname}`
- **Utility**: servizi relativi a utility, es. `GET /timesheet/{id-timesheet}`...

#### Implementazione e tecnologie

Qualsiasi API HTTP è abbastanza, ma esistono linguaggi per le API dedicate, es. JAX-RS, API for Resftul Web Services.

#### Confronto Restful vs Soapful




## Microservizi