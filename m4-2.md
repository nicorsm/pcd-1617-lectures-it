# PCD Module 4.2

**Sistemi distribuiti: qualche algoritmo**

## Algoritmi distribuiti

- Sfide principali: non ci sono clock e memorie condivise, fallimenti. 
- Idea generale: utilizzo di clock logici e relazione _happened-before_ per definire un ordine tra eventi correlati.
- Presupposizioni per molti algoritmi:
	- sistemi asincroni senza fallimenti - finiti ma tempo di consegna non conosciuto a priori
	- sistemi sincroni quando si parla di errori - timeout
- Principali categorie:
	- **coordinamento**
	- **osservazione**
	- **controllo**
	
### Mutex e CS

- Analogo al problema nel caso concorrente, qui i processi sono distribuiti
- Proprietà della CS:
	- **sicurezza**: due processi non devono avere il permesso di essere nella CS simultaneamente
	- **vitalità**: ogni richiesta alla CS deve essere eventualmente garantita
	- **equità**: richieste diverse devono essere garantite nell'ordine che sono state fatte.

## Algoritmo di Agrawala

- per richiedere una risorsa, il processo invia un messaggio timestamp a tutti i processi
- alla ricezione della richiesta da qualsiasi altro processo, il processo invia un messaggio OK se non è interessato ad entrare nella CS o se la richiesta stessa ha un timestamp più alto. Altrimenti tale processo è mantenuto in una coda.
- per rilasciare una risorsa, il processo $P_i$ invia OK a tutti gli altri processi in coda
- $P_i$ viene concesso alla risorsa quando è richiesto dalla risorsa e ha ricevuto OK da tutti gli altri processi in risposta al messaggio di richiesta.

```
Pi::var    pendingQ: list of process ids initially null    myts: integer timestamp initially infinity    numOK: integer initially 0request:    myts := logical_clock    send req with myts to all other processes    numOK := 0receive(u,req):    if (u.myts < myts)       send OK to process u.pid    else       append(pendingQ,u.pid)receive(u,OK):    numOK := numOK + 1    if (numOK == N-1)enter_CSrelease:    myts := infinity    for each pid in pendingQ       send OK to pid    empty(pendingQ)
```

- Completamente decentralizzato
- Numero di messaggi: $2 \times (N-1)$
- Lavora con canali non necessariamente FIFO

## Algoritmo centralizzato

- C'è un coordinatore che assegna i token
- Punto chiave: **equità**
	- le richieste devono avere accesso in accordo con la relazione _happened-before_
	- se $s \rightarrow t$, la richiesta $s$ deve essere servita prima di $t$, con $s,t$ = due stati locali corrispondenti a eventi di richiesta
	- se una richiesta $t$ arriva al coordinatore prima di $s$, il coordinatore dev'essere in grado che c'è una richiesta in sospeso dal processo $P$ relativo a $s$.
	- dal momento che $s \rightarrow t$, $r$ ha informazioni su $s$: il processo $P$ correlato a $t$ ha bisogno solamente di appoggiarsi sul coordinatore per le richieste che conosce
	- il coordinatore può ritardare la ricezione del messaggio $t$ finchè tutte le richieste prima di $t$ vengono ricevute.
	- informazioni sulle richieste conosciute nello stato $s$ sono catturate tramite un vettore $s.v$, dove $s.v[j]$ rappresenta il numero di richieste fatte da $P_j$ che precedono causalmente lo stato $s$.
- Idea
	- i processi cooperano portandosi a cavallo del porco (piggybacking) il vettore clock $v$ su tutti i processi in uscita.  
	- il processo coordinatore ritarda una richiesta $t$ finchè tutte le richieste prima di $t$ vengono ricevute.
		- `redone` = vettore t.c. `reqdone[i]` = n° di richieste fatte da $P_i$ che sono state soddisfatte.
		- `reqlist` = lista di richieste ricevute da $P_0$ che non sono state ancora soddisfatte
		- richieste ammissibili = una richiesta $w$ è ammissibile se $w.v$ è almeno `reqdone` - non ci sono richieste accadute prima di $w$ e non sono state già soddisfatte

```
Peers

Pi:: var    v: array[1..N] of integer := [0]    inCS: boolean := falseTo request:    v[i] := v[i] + 1    send (req, v) to P0Upon receive(token) from P0:    inCS := trueTo release:    send token to P0    inCS := falseUpon receive(u):    v:= max(v,u.v)
    
Coordinator

P0::var    reqDone: array[1..N] of integer := [0]    reqList: list of (pid, reqvector) := empty    haveToken: boolean := trueUpon receive(u,req):    append(reqList,u)    if (haveToken)checkReq()Upon receive(u,token):    haveToken := true    checkReq()checkReq:    eligible := {w in reqList|for each j, j != w.p:                 w.v[j] <= reqDone[j] }    if (eligible != {})       w := first(eligible)       delete(reqList,w)       reqDone[w.p] := reqDone[w.p] + 1       send token to Pw.p       haveToken := false
```

### Ulteriori approcci

- **Sistema di voto basato su quorum**
	- gli approcci basati su token sono vulnerabili ai fallimenti dei processi che trattengono i token
	- le strategie basate su quorum non hanno un singolo punto di fallimento
	- **Elezione del leader**:
		- si sceglie un processo in un insieme di $N$ processi
		- basato su superimporre una topologia logica ad anello nella rete sottostante per eseguire funzioni di controllo
		- strategia largamente usata per scegliere coordinatori negli algoritmi centralizzati.
	 
## Algoritmo di Chang-Roberts

- Presupposto: ogni processo ha un PID univoco
- Idea: 
	- il processo con il PID più alto viene scelto
	- uno o più processi possono spontaneamente svegliarsi e iniziare un'elezione
	- un processo:
		- invia il messaggio di elezione assieme al suo ID alla sua sinistra, se non ha visto alcun messaggio con un identificatore più alto del suo
		- inoltra qualsiasi messaggio che ha un ID maggiore del suo, altrimenti digerisce il messaggio
		- se un processo riceve il suo stesso messaggio, si dichiara leader e propaga il messaggio leader

```
Pi::var    myid: integer    awake: boolean := false    leaderId: integer := nullTo initiate election:    send (election,myid) to P(i-1)    awake := trueUpon receiving a message (election,j):    if (j > myid)       send (election,j) to P(i-1)    else if (j == myid)       send (leader,myid) to P(i-1)    else if ((j < myid) and !awake)       send (election, myid) to P(i-1)    awake := trueUpon receiving a message (leader,j):    leaderId := j    if (j != myid)       send (leader,j) to P(i-1)
``` 

- Numero di messaggi scambiati:
	- caso peggiore: $sum(1,N) = O(N^2) + N$ messaggi leader
	- caso migliore: $O(N)$
	- media: $O(N log N)$

### Stato globale

- Catturare lo stato globale del sistema distribuito da un singolo processo:
	- **stato globale**: insieme di stati locali che sono tutti concorrenti con gli altri, in accordo col modello _happened-before_
	- per molte applicazioni, è abbastanza catturare uno stato globale che è accaduto in passato, non il corrente
- Un algorimto che cattura lo stato globale è chiamato **Global snapshot algorithm**
- Sfida: un numero consistente di stati globali non sono semplicemente il prodotto di stati locali.
	- **taglio consistente**: a global state S where ∀ event e | e = receive(msg),   S ∋ e', where e' = send(msg), e' → e 

## Algoritmo snapshot Chandy-Lamport

### Ulteriori problematiche

## Ordinamento messaggi causale

### Ulteriori esplorazioni

## Sincronizzatori

## Consenso


### Consenso con sincronia

### Consenso per modello di crash

### Osservazioni

### Consenso sotto guasti Bizantini

### Ulteriori esplorazioni

### Rivelatore di guasti


